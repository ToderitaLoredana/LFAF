# Intro to formal languages. Regular grammars. Finite Automata.

### Course: Formal Languages & Finite Automata
### Author: Toderita Loredana
### Variant: 23

----

## Theory

A **formal language** is a set of strings built from a finite alphabet according to a specific set of rules. These rules are defined by a **grammar**, which is a mathematical structure consisting of four components: a set of non-terminal symbols (V_n), a set of terminal symbols (V_t), a set of production rules (P), and a start symbol (S). Non-terminals are placeholders used during derivation, while terminals are the actual characters that appear in the final generated strings.

A **regular grammar** is a specific type of formal grammar where each production rule has a restricted form. In a right-linear regular grammar, every production is either of the form `A → aB` (a terminal followed by a non-terminal) or `A → a` (a single terminal). This restriction ensures that the language generated by the grammar is a **regular language**, which can be recognized by a finite automaton.

A **Finite Automaton (FA)** is an abstract computational model defined by five components: a set of states (Q), an input alphabet (Σ), a transition function (δ), a start state (q₀), and a set of accepting/final states (F). The automaton reads an input string character by character and transitions between states according to δ. If, after processing the entire string, the automaton is in one of the accepting states, the string is accepted; otherwise, it is rejected. A **Nondeterministic Finite Automaton (NFA)** allows multiple possible transitions for the same state-symbol pair, meaning it can be in several states simultaneously.

There is a well-known equivalence between regular grammars and finite automata: any regular grammar can be converted into an equivalent finite automaton, and vice versa. This makes it possible to generate strings from a grammar and then verify their membership using the corresponding automaton.

## Objectives:

1. Discover what a language is and what it needs to have in order to be considered a formal one.
2. Provide the initial setup for the evolving project that will be worked on during this semester.
    - Create a GitHub repository for the project.
    - Choose a programming language.
    - Create a separate folder for reports (if needed).
3. According to the given variant (Variant 23), get the grammar definition and do the following tasks:
    a. Implement a type/class for the grammar.
    b. Add a function that generates 5 valid strings from the language expressed by the given grammar.
    c. Implement a functionality that converts a Grammar object to a Finite Automaton object.
    d. Add a method in the Finite Automaton class that checks if an input string can be obtained via the state transitions of the automaton (i.e., whether the string belongs to the language).

## Implementation description

### Grammar Definition (Variant 23)

The grammar for Variant 23 is defined as follows:
- **V_n** = {S, B, C}
- **V_t** = {a, b, c}
- **P** (Productions):
    - S → aB
    - B → aC | bB
    - C → bB | c | aS

The `Grammar` class stores non-terminals, terminals, productions, and the start symbol. A factory method `variant23()` encapsulates the specific grammar for our variant. A `validate()` method ensures the grammar is well-formed (the start symbol exists in V_n, all LHS are non-terminals, and all RHS conform to the right-linear format).

```java
public static Grammar variant23() {
    Set<String> vn = new LinkedHashSet<>(Arrays.asList("S", "B", "C"));
    Set<Character> vt = new LinkedHashSet<>(Arrays.asList('a', 'b', 'c'));

    Map<String, List<String>> p = new LinkedHashMap<>();
    p.put("S", Arrays.asList("aB"));
    p.put("B", Arrays.asList("aC", "bB"));
    p.put("C", Arrays.asList("bB", "c", "aS"));

    return new Grammar(vn, vt, p, "S");
}
```

### String Generation

The `generateString()` method generates valid strings by repeatedly replacing the first non-terminal in the current sentential form with a randomly chosen right-hand side from the productions. To avoid infinite loops caused by cycles in the grammar (e.g., C → aS can loop back), the method uses a maximum step count and multiple attempts. Additionally, when the non-terminal `C` is being expanded, the terminal production `c` is given a higher weight to encourage termination.

```java
public String generateString(int maxSteps) {
    for (int attempt = 0; attempt < 50; attempt++) {
        String current = startSymbol;
        int steps = 0;

        while (containsAnyNonTerminal(current)) {
            if (steps++ > maxSteps) break;

            int idx = indexOfFirstNonTerminal(current);
            String nt = String.valueOf(current.charAt(idx));

            List<String> rhsOptions = productions.get(nt);
            if (rhsOptions == null || rhsOptions.isEmpty()) break;

            String chosen;
            if ("C".equals(nt)) {
                chosen = weightedChoice(rhsOptions, Map.of("c", 3));
            } else {
                chosen = rhsOptions.get(random.nextInt(rhsOptions.size()));
            }

            current = current.substring(0, idx) + chosen + current.substring(idx + 1);
        }

        if (!containsAnyNonTerminal(current)) {
            return current;
        }
    }
    throw new IllegalStateException("Failed to generate a valid string.");
}
```

### Grammar to Finite Automaton Conversion

The `toFiniteAutomaton()` method converts the regular grammar into an equivalent NFA. The conversion follows a standard algorithm:
- Each non-terminal becomes a state in the automaton.
- An additional `FINAL` state is introduced as the sole accepting state.
- For each production `A → aB`, a transition δ(A, a) → B is added.
- For each production `A → a` (terminal-only), a transition δ(A, a) → FINAL is added.

This ensures that a string is accepted by the automaton if and only if it can be derived from the grammar.

```java
public FiniteAutomaton toFiniteAutomaton() {
    String FINAL = "FINAL";

    Set<String> states = new LinkedHashSet<>(nonTerminals);
    states.add(FINAL);

    Set<String> accepting = new LinkedHashSet<>();
    accepting.add(FINAL);

    Map<String, Map<Character, Set<String>>> delta = new LinkedHashMap<>();
    for (String q : states) delta.put(q, new LinkedHashMap<>());

    for (Map.Entry<String, List<String>> e : productions.entrySet()) {
        String from = e.getKey();
        for (String rhs : e.getValue()) {
            char symbol = rhs.charAt(0);
            String to = (rhs.length() == 2) ? String.valueOf(rhs.charAt(1)) : FINAL;

            delta.get(from)
                    .computeIfAbsent(symbol, k -> new LinkedHashSet<>())
                    .add(to);
        }
    }

    return new FiniteAutomaton(states, terminals, delta, startSymbol, accepting);
}
```

### Finite Automaton — String Membership Check

The `FiniteAutomaton` class models an NFA with states (Q), alphabet (Σ), transition function (δ), start state (q₀), and accepting states (F). The `stringBelongToLanguage()` method simulates the NFA by maintaining a set of current states. For each character in the input, it computes all possible next states. If after processing the entire string at least one current state is an accepting state, the string is accepted.

```java
public boolean stringBelongToLanguage(final String inputString) {
    if (inputString == null) return false;

    Set<String> current = new LinkedHashSet<>();
    current.add(startState);

    for (int i = 0; i < inputString.length(); i++) {
        char ch = inputString.charAt(i);
        if (!alphabet.contains(ch)) return false;

        Set<String> next = new LinkedHashSet<>();
        for (String state : current) {
            Map<Character, Set<String>> map = delta.get(state);
            if (map == null) continue;
            Set<String> targets = map.get(ch);
            if (targets != null) next.addAll(targets);
        }
        current = next;
        if (current.isEmpty()) return false;
    }

    for (String st : current) {
        if (acceptingStates.contains(st)) return true;
    }
    return false;
}
```

## Conclusions / Screenshots / Results

### Results

Running the program produces the following output:

```
 Lab 1 — Variant 23 
Generated valid strings (and FA check):
1. abbababbbac  -> true
2. aaaaac       -> true
3. aac          -> true
4. abac         -> true
5. abbac        -> true

Membership tests:
  c        -> false
  aac      -> true
  abac     -> true
  aa       -> false
  aba      -> false
  ababc    -> false
```

All 5 randomly generated strings are correctly recognized by the finite automaton (all return `true`). The membership tests confirm that:
- Strings like `aac` (derivation: S → aB → aC → c) and `abac` (derivation: S → aB → bB → aC → c) are correctly accepted.
- Invalid strings like `c` (cannot start from S with `c`), `aa` and `aba` (incomplete derivations with no terminal ending) are correctly rejected.

### Conclusions

In this laboratory work, I implemented a regular grammar and a finite automaton in Java for **Variant 23**. The key takeaways are:

1. **Regular grammars** provide a systematic way to define languages through production rules. The right-linear form ensures the generated language is regular.
2. **String generation** from a grammar can be achieved through random derivation, but care must be taken with cyclic productions (like C → aS) to avoid infinite loops — this was handled using a step limit and weighted random choices.
3. The **conversion from grammar to finite automaton** follows a straightforward algorithm: non-terminals become states, and productions become transitions, with a special accepting state for terminal-only productions.
4. The **NFA simulation** correctly handles nondeterminism by tracking all possible states simultaneously, providing an accurate membership check for any input string.
5. The equivalence between the grammar and the automaton was verified: every string generated by the grammar was accepted by the automaton, and manually constructed invalid strings were correctly rejected.

## References

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation* (3rd ed.). Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd ed.). Cengage Learning.
3. Course materials — Formal Languages & Finite Automata, TUM.